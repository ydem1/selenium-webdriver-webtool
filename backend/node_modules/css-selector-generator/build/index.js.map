{"version":3,"file":"index.js","mappings":"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","sources":["webpack://CssSelectorGenerator/webpack/universalModuleDefinition","webpack://CssSelectorGenerator/webpack/bootstrap","webpack://CssSelectorGenerator/webpack/runtime/define property getters","webpack://CssSelectorGenerator/webpack/runtime/hasOwnProperty shorthand","webpack://CssSelectorGenerator/webpack/runtime/make namespace object","webpack://CssSelectorGenerator/./temp/utilities-iselement.js","webpack://CssSelectorGenerator/./temp/types.js","webpack://CssSelectorGenerator/./temp/utilities-messages.js","webpack://CssSelectorGenerator/./temp/utilities-options.js","webpack://CssSelectorGenerator/./temp/utilities-data.js","webpack://CssSelectorGenerator/./temp/utilities-dom.js","webpack://CssSelectorGenerator/./temp/constants.js","webpack://CssSelectorGenerator/./temp/selector-attribute.js","webpack://CssSelectorGenerator/./temp/selector-class.js","webpack://CssSelectorGenerator/./temp/selector-id.js","webpack://CssSelectorGenerator/./temp/selector-nth-child.js","webpack://CssSelectorGenerator/./temp/selector-tag.js","webpack://CssSelectorGenerator/./temp/selector-nth-of-type.js","webpack://CssSelectorGenerator/./temp/utilities-powerset.js","webpack://CssSelectorGenerator/./temp/utilities-selectors.js","webpack://CssSelectorGenerator/./temp/utilities-cartesian.js","webpack://CssSelectorGenerator/./temp/utilities-element-data.js","webpack://CssSelectorGenerator/./temp/selector-fallback.js","webpack://CssSelectorGenerator/./temp/index.js","webpack://CssSelectorGenerator/./temp/utilities-typescript.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CssSelectorGenerator\"] = factory();\n\telse\n\t\troot[\"CssSelectorGenerator\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Guard function that checks if provided `input` is an Element.\n */\nexport function isElement(input) {\n    return input && input instanceof Element;\n}\n//# sourceMappingURL=utilities-iselement.js.map","export const OPERATOR = {\n    NONE: \"\",\n    DESCENDANT: \" \",\n    CHILD: \" > \",\n};\nexport const CSS_SELECTOR_TYPE = {\n    id: \"id\",\n    class: \"class\",\n    tag: \"tag\",\n    attribute: \"attribute\",\n    nthchild: \"nthchild\",\n    nthoftype: \"nthoftype\",\n};\n//# sourceMappingURL=types.js.map","const libraryName = \"CssSelectorGenerator\";\n/**\n * Convenient wrapper for `console.warn` using consistent formatting.\n */\nexport function showWarning(id = \"unknown problem\", ...args) {\n    // eslint-disable-next-line no-console\n    console.warn(`${libraryName}: ${id}`, ...args);\n}\n//# sourceMappingURL=utilities-messages.js.map","import { CSS_SELECTOR_TYPE, } from \"./types.js\";\nimport { isEnumValue } from \"./utilities-typescript.js\";\nimport { showWarning } from \"./utilities-messages.js\";\nexport const DEFAULT_OPTIONS = {\n    selectors: [\n        CSS_SELECTOR_TYPE.id,\n        CSS_SELECTOR_TYPE.class,\n        CSS_SELECTOR_TYPE.tag,\n        CSS_SELECTOR_TYPE.attribute,\n    ],\n    // if set to true, always include tag name\n    includeTag: false,\n    whitelist: [],\n    blacklist: [],\n    combineWithinSelector: true,\n    combineBetweenSelectors: true,\n    root: null,\n    maxCombinations: Number.POSITIVE_INFINITY,\n    maxCandidates: Number.POSITIVE_INFINITY,\n};\n/**\n * Makes sure returned value is a list containing only valid selector types.\n * @param input\n */\nexport function sanitizeSelectorTypes(input) {\n    if (!Array.isArray(input)) {\n        return [];\n    }\n    return input.filter((item) => isEnumValue(CSS_SELECTOR_TYPE, item));\n}\n/**\n * Checks whether provided value is of type RegExp.\n */\nexport function isRegExp(input) {\n    return input instanceof RegExp;\n}\n/**\n * Checks whether provided value is usable in whitelist or blacklist.\n * @param input\n */\nexport function isCssSelectorMatch(input) {\n    return [\"string\", \"function\"].includes(typeof input) || isRegExp(input);\n}\n/**\n * Converts input to a list of valid values for whitelist or blacklist.\n */\nexport function sanitizeCssSelectorMatchList(input) {\n    if (!Array.isArray(input)) {\n        return [];\n    }\n    return input.filter(isCssSelectorMatch);\n}\n/**\n * Checks whether provided value is valid Node.\n */\nexport function isNode(input) {\n    return input instanceof Node;\n}\n/**\n * Checks whether provided value is valid ParentNode.\n */\nexport function isParentNode(input) {\n    const validParentNodeTypes = [\n        Node.DOCUMENT_NODE,\n        Node.DOCUMENT_FRAGMENT_NODE, // this includes Shadow DOM root\n        Node.ELEMENT_NODE,\n    ];\n    return isNode(input) && validParentNodeTypes.includes(input.nodeType);\n}\n/**\n * Makes sure that the root node in options is valid.\n */\nexport function sanitizeRoot(input, element) {\n    if (isParentNode(input)) {\n        if (!input.contains(element)) {\n            // eslint-disable-next-line max-len\n            showWarning(\"element root mismatch\", \"Provided root does not contain the element. This will most likely result in producing a fallback selector using element's real root node. If you plan to use the selector using provided root (e.g. `root.querySelector`), it will nto work as intended.\");\n        }\n        return input;\n    }\n    const rootNode = element.getRootNode({ composed: false });\n    if (isParentNode(rootNode)) {\n        if (rootNode !== document) {\n            // eslint-disable-next-line max-len\n            showWarning(\"shadow root inferred\", \"You did not provide a root and the element is a child of Shadow DOM. This will produce a selector using ShadowRoot as a root. If you plan to use the selector using document as a root (e.g. `document.querySelector`), it will not work as intended.\");\n        }\n        return rootNode;\n    }\n    return element.ownerDocument.querySelector(\":root\");\n}\n/**\n * Makes sure that the output is a number, usable as `maxResults` option in\n * powerset generator.\n */\nexport function sanitizeMaxNumber(input) {\n    return typeof input === \"number\" ? input : Number.POSITIVE_INFINITY;\n}\n/**\n * Makes sure the options object contains all required keys.\n */\nexport function sanitizeOptions(element, custom_options = {}) {\n    const options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), custom_options);\n    return {\n        selectors: sanitizeSelectorTypes(options.selectors),\n        whitelist: sanitizeCssSelectorMatchList(options.whitelist),\n        blacklist: sanitizeCssSelectorMatchList(options.blacklist),\n        root: sanitizeRoot(options.root, element),\n        combineWithinSelector: !!options.combineWithinSelector,\n        combineBetweenSelectors: !!options.combineBetweenSelectors,\n        includeTag: !!options.includeTag,\n        maxCombinations: sanitizeMaxNumber(options.maxCombinations),\n        maxCandidates: sanitizeMaxNumber(options.maxCandidates),\n    };\n}\n//# sourceMappingURL=utilities-options.js.map","import { isRegExp } from \"./utilities-options.js\";\nimport { showWarning } from \"./utilities-messages.js\";\n/**\n * Creates array containing only items included in all input arrays.\n */\nexport function getIntersection(items = []) {\n    const [firstItem = [], ...otherItems] = items;\n    if (otherItems.length === 0) {\n        return firstItem;\n    }\n    return otherItems.reduce((accumulator, currentValue) => {\n        return accumulator.filter((item) => currentValue.includes(item));\n    }, firstItem);\n}\n/**\n * Converts array of arrays into a flat array.\n */\nexport function flattenArray(input) {\n    return [].concat(...input);\n}\n/**\n * Convert string that can contain wildcards (asterisks) to RegExp source.\n */\nexport function wildcardToRegExp(input) {\n    return (input\n        // convert all special characters used by RegExp, except an asterisk\n        .replace(/[|\\\\{}()[\\]^$+?.]/g, \"\\\\$&\")\n        // convert asterisk to pattern that matches anything\n        .replace(/\\*/g, \".+\"));\n}\n/**\n * Creates function that will test list of provided matchers against input.\n * Used for white/blacklist functionality.\n */\nexport function createPatternMatcher(list) {\n    const matchFunctions = list.map((item) => {\n        if (isRegExp(item)) {\n            return (input) => item.test(input);\n        }\n        if (typeof item === \"function\") {\n            return (input) => {\n                const result = item(input);\n                if (typeof result !== \"boolean\") {\n                    // eslint-disable-next-line max-len\n                    showWarning(\"pattern matcher function invalid\", \"Provided pattern matching function does not return boolean. It's result will be ignored.\", item);\n                    return false;\n                }\n                return result;\n            };\n        }\n        if (typeof item === \"string\") {\n            const re = new RegExp(\"^\" + wildcardToRegExp(item) + \"$\");\n            return (input) => re.test(input);\n        }\n        // eslint-disable-next-line max-len\n        showWarning(\"pattern matcher invalid\", \"Pattern matching only accepts strings, regular expressions and/or functions. This item is invalid and will be ignored.\", item);\n        return () => false;\n    });\n    return (input) => matchFunctions.some((matchFunction) => matchFunction(input));\n}\n//# sourceMappingURL=utilities-data.js.map","import { isElement } from \"./utilities-iselement.js\";\nimport { getIntersection } from \"./utilities-data.js\";\nimport { sanitizeRoot } from \"./utilities-options.js\";\n/**\n * Check whether element is matched uniquely by selector.\n */\nexport function testSelector(elements, selector, root) {\n    const result = Array.from(sanitizeRoot(root, elements[0]).querySelectorAll(selector));\n    return (result.length === elements.length &&\n        elements.every((element) => result.includes(element)));\n}\n/**\n * Test whether selector targets element. It does not have to be a unique match.\n */\nexport function testMultiSelector(element, selector, root) {\n    const result = Array.from(sanitizeRoot(root, element).querySelectorAll(selector));\n    return result.includes(element);\n}\n/**\n * Find all parents of a single element.\n */\nexport function getElementParents(element, root) {\n    root = root !== null && root !== void 0 ? root : getRootNode(element);\n    const result = [];\n    let parent = element;\n    while (isElement(parent) && parent !== root) {\n        result.push(parent);\n        parent = parent.parentElement;\n    }\n    return result;\n}\n/**\n * Find all common parents of elements.\n */\nexport function getParents(elements, root) {\n    return getIntersection(elements.map((element) => getElementParents(element, root)));\n}\n/**\n * Returns root node for given element. This needs to be used because of document-less environments, e.g. jsdom.\n */\nexport function getRootNode(element) {\n    return element.ownerDocument.querySelector(\":root\");\n}\n//# sourceMappingURL=utilities-dom.js.map","import { CSS_SELECTOR_TYPE } from \"./types.js\";\nexport const SELECTOR_SEPARATOR = \", \";\n// RegExp that will match invalid patterns that can be used in ID attribute.\nexport const INVALID_ID_RE = new RegExp([\n    \"^$\", // empty or not set\n    \"\\\\s\", // contains whitespace\n].join(\"|\"));\n// RegExp that will match invalid patterns that can be used in class attribute.\nexport const INVALID_CLASS_RE = new RegExp([\n    \"^$\", // empty or not set\n].join(\"|\"));\n// Order in which a combined selector is constructed.\nexport const SELECTOR_PATTERN = [\n    CSS_SELECTOR_TYPE.nthoftype,\n    CSS_SELECTOR_TYPE.tag,\n    CSS_SELECTOR_TYPE.id,\n    CSS_SELECTOR_TYPE.class,\n    CSS_SELECTOR_TYPE.attribute,\n    CSS_SELECTOR_TYPE.nthchild,\n];\n//# sourceMappingURL=constants.js.map","import { sanitizeSelectorItem } from \"./utilities-selectors.js\";\nimport { createPatternMatcher, getIntersection } from \"./utilities-data.js\";\n// List of attributes to be ignored. These are handled by different selector types.\nexport const attributeBlacklistMatch = createPatternMatcher([\n    \"class\",\n    \"id\",\n    // Angular attributes\n    \"ng-*\",\n]);\n/**\n * Get simplified attribute selector for an element.\n */\nexport function attributeNodeToSimplifiedSelector({ name, }) {\n    return `[${name}]`;\n}\n/**\n * Get attribute selector for an element.\n */\nexport function attributeNodeToSelector({ name, value, }) {\n    return `[${name}='${value}']`;\n}\n/**\n * Checks whether attribute should be used as a selector.\n */\nexport function isValidAttributeNode({ nodeName }, element) {\n    // form input value should not be used as a selector\n    const tagName = element.tagName.toLowerCase();\n    if ([\"input\", \"option\"].includes(tagName) && nodeName === \"value\") {\n        return false;\n    }\n    return !attributeBlacklistMatch(nodeName);\n}\n/**\n * Sanitize all attribute data. We want to do it once, before we start to generate simplified/full selectors from the same data.\n */\nfunction sanitizeAttributeData({ nodeName, nodeValue }) {\n    return {\n        name: sanitizeSelectorItem(nodeName),\n        value: sanitizeSelectorItem(nodeValue),\n    };\n}\n/**\n * Get attribute selectors for an element.\n */\nexport function getElementAttributeSelectors(element) {\n    const validAttributes = Array.from(element.attributes)\n        .filter((attributeNode) => isValidAttributeNode(attributeNode, element))\n        .map(sanitizeAttributeData);\n    return [\n        ...validAttributes.map(attributeNodeToSimplifiedSelector),\n        ...validAttributes.map(attributeNodeToSelector),\n    ];\n}\n/**\n * Get attribute selectors matching all elements.\n */\nexport function getAttributeSelectors(elements) {\n    const elementSelectors = elements.map(getElementAttributeSelectors);\n    return getIntersection(elementSelectors);\n}\n//# sourceMappingURL=selector-attribute.js.map","import { sanitizeSelectorItem } from \"./utilities-selectors.js\";\nimport { INVALID_CLASS_RE } from \"./constants.js\";\nimport { getIntersection } from \"./utilities-data.js\";\n/**\n * Get class selectors for an element.\n */\nexport function getElementClassSelectors(element) {\n    return (element.getAttribute(\"class\") || \"\")\n        .trim()\n        .split(/\\s+/)\n        .filter((item) => !INVALID_CLASS_RE.test(item))\n        .map((item) => `.${sanitizeSelectorItem(item)}`);\n}\n/**\n * Get class selectors matching all elements.\n */\nexport function getClassSelectors(elements) {\n    const elementSelectors = elements.map(getElementClassSelectors);\n    return getIntersection(elementSelectors);\n}\n//# sourceMappingURL=selector-class.js.map","import { sanitizeSelectorItem } from \"./utilities-selectors.js\";\nimport { INVALID_ID_RE } from \"./constants.js\";\nimport { testSelector } from \"./utilities-dom.js\";\n/**\n * Get ID selector for an element.\n * */\nexport function getElementIdSelectors(element) {\n    const id = element.getAttribute(\"id\") || \"\";\n    const selector = `#${sanitizeSelectorItem(id)}`;\n    const rootNode = element.getRootNode({ composed: false });\n    return !INVALID_ID_RE.test(id) && testSelector([element], selector, rootNode)\n        ? [selector]\n        : [];\n}\n/**\n * Get ID selector for an element.\n */\nexport function getIdSelector(elements) {\n    return elements.length === 0 || elements.length > 1\n        ? []\n        : getElementIdSelectors(elements[0]);\n}\n//# sourceMappingURL=selector-id.js.map","import { isElement } from \"./utilities-iselement.js\";\nimport { getIntersection } from \"./utilities-data.js\";\n/**\n * Get nth-child selector for an element.\n */\nexport function getElementNthChildSelector(element) {\n    const parent = element.parentNode;\n    if (parent) {\n        const siblings = Array.from(parent.childNodes).filter(isElement);\n        const elementIndex = siblings.indexOf(element);\n        if (elementIndex > -1) {\n            return [`:nth-child(${elementIndex + 1})`];\n        }\n    }\n    return [];\n}\n/**\n * Get nth-child selector matching all elements.\n */\nexport function getNthChildSelector(elements) {\n    return getIntersection(elements.map(getElementNthChildSelector));\n}\n//# sourceMappingURL=selector-nth-child.js.map","import { sanitizeSelectorItem } from \"./utilities-selectors.js\";\nimport { flattenArray } from \"./utilities-data.js\";\n/**\n * Get tag selector for an element.\n */\nexport function getElementTagSelectors(element) {\n    return [\n        sanitizeSelectorItem(element.tagName.toLowerCase()),\n    ];\n}\n/**\n * Get tag selector for list of elements.\n */\nexport function getTagSelector(elements) {\n    const selectors = [\n        ...new Set(flattenArray(elements.map(getElementTagSelectors))),\n    ];\n    return selectors.length === 0 || selectors.length > 1 ? [] : [selectors[0]];\n}\n//# sourceMappingURL=selector-tag.js.map","import { getTagSelector } from \"./selector-tag.js\";\nimport { getIntersection } from \"./utilities-data.js\";\n/**\n * Get nth-of-type selector for an element.\n */\nexport function getElementNthOfTypeSelector(element) {\n    const tag = getTagSelector([element])[0];\n    const parentElement = element.parentElement;\n    if (parentElement) {\n        const siblings = Array.from(parentElement.children).filter((element) => element.tagName.toLowerCase() === tag);\n        const elementIndex = siblings.indexOf(element);\n        if (elementIndex > -1) {\n            return [\n                `${tag}:nth-of-type(${elementIndex + 1})`,\n            ];\n        }\n    }\n    return [];\n}\n/**\n * Get Nth-of-type selector matching all elements.\n */\nexport function getNthOfTypeSelector(elements) {\n    return getIntersection(elements.map(getElementNthOfTypeSelector));\n}\n//# sourceMappingURL=selector-nth-of-type.js.map","export function* powerSetGenerator(input = [], { maxResults = Number.POSITIVE_INFINITY } = {}) {\n    let resultCounter = 0;\n    let offsets = generateOffsets(1);\n    while (offsets.length <= input.length && resultCounter < maxResults) {\n        resultCounter += 1;\n        const result = offsets.map((offset) => input[offset]);\n        yield result;\n        offsets = bumpOffsets(offsets, input.length - 1);\n    }\n}\n/**\n * Generates power set of input items.\n */\nexport function getPowerSet(input = [], { maxResults = Number.POSITIVE_INFINITY } = {}) {\n    return Array.from(powerSetGenerator(input, { maxResults }));\n}\n/**\n * Helper function used by `getPowerSet`. Updates internal pointers.\n */\nfunction bumpOffsets(offsets = [], maxValue = 0) {\n    const size = offsets.length;\n    if (size === 0) {\n        return [];\n    }\n    const result = [...offsets];\n    result[size - 1] += 1;\n    for (let index = size - 1; index >= 0; index--) {\n        if (result[index] > maxValue) {\n            if (index === 0) {\n                return generateOffsets(size + 1);\n            }\n            else {\n                result[index - 1]++;\n                result[index] = result[index - 1] + 1;\n            }\n        }\n    }\n    if (result[size - 1] > maxValue) {\n        return generateOffsets(size + 1);\n    }\n    return result;\n}\n/**\n * Generates array of size N, filled with numbers sequence starting from 0.\n */\nfunction generateOffsets(size = 1) {\n    return Array.from(Array(size).keys());\n}\n//# sourceMappingURL=utilities-powerset.js.map","import { SELECTOR_PATTERN } from \"./constants.js\";\nimport { getAttributeSelectors, getElementAttributeSelectors, } from \"./selector-attribute.js\";\nimport { getClassSelectors, getElementClassSelectors, } from \"./selector-class.js\";\nimport { getElementIdSelectors, getIdSelector } from \"./selector-id.js\";\nimport { getElementNthChildSelector, getNthChildSelector, } from \"./selector-nth-child.js\";\nimport { getElementNthOfTypeSelector, getNthOfTypeSelector, } from \"./selector-nth-of-type.js\";\nimport { getElementTagSelectors, getTagSelector } from \"./selector-tag.js\";\nimport { createPatternMatcher, flattenArray } from \"./utilities-data.js\";\nimport { getParents, testSelector } from \"./utilities-dom.js\";\nimport { CSS_SELECTOR_TYPE, OPERATOR, } from \"./types.js\";\nimport { isElement } from \"./utilities-iselement.js\";\nimport { getPowerSet } from \"./utilities-powerset.js\";\nimport { getCartesianProduct } from \"./utilities-cartesian.js\";\nexport const ESCAPED_COLON = \":\".charCodeAt(0).toString(16).toUpperCase();\n// Square brackets need to be escaped, but eslint has a problem with that.\n/* eslint-disable-next-line no-useless-escape */\nexport const SPECIAL_CHARACTERS_RE = /[ !\"#$%&'()\\[\\]{|}<>*+,./;=?@^`~\\\\]/;\n/**\n * Escapes special characters used by CSS selector items.\n */\nexport function sanitizeSelectorItem(input = \"\") {\n    var _a, _b;\n    return (_b = (_a = CSS === null || CSS === void 0 ? void 0 : CSS.escape) === null || _a === void 0 ? void 0 : _a.call(CSS, input)) !== null && _b !== void 0 ? _b : legacySanitizeSelectorItem(input);\n}\n/**\n * Legacy version of escaping utility, originally used for IE11-. Should\n * probably be replaced by a polyfill:\n * https://github.com/mathiasbynens/CSS.escape\n */\nexport function legacySanitizeSelectorItem(input = \"\") {\n    return input\n        .split(\"\")\n        .map((character) => {\n        if (character === \":\") {\n            return `\\\\${ESCAPED_COLON} `;\n        }\n        if (SPECIAL_CHARACTERS_RE.test(character)) {\n            return `\\\\${character}`;\n        }\n        return escape(character).replace(/%/g, \"\\\\\");\n    })\n        .join(\"\");\n}\nexport const SELECTOR_TYPE_GETTERS = {\n    tag: getTagSelector,\n    id: getIdSelector,\n    class: getClassSelectors,\n    attribute: getAttributeSelectors,\n    nthchild: getNthChildSelector,\n    nthoftype: getNthOfTypeSelector,\n};\nexport const ELEMENT_SELECTOR_TYPE_GETTERS = {\n    tag: getElementTagSelectors,\n    id: getElementIdSelectors,\n    class: getElementClassSelectors,\n    attribute: getElementAttributeSelectors,\n    nthchild: getElementNthChildSelector,\n    nthoftype: getElementNthOfTypeSelector,\n};\n/**\n * Creates selector of given type for single element.\n */\nexport function getElementSelectorsByType(element, selectorType) {\n    return ELEMENT_SELECTOR_TYPE_GETTERS[selectorType](element);\n}\n/**\n * Returns list of selectors of given type for the element.\n */\nexport function getSelectorsByType(elements, selector_type) {\n    var _a;\n    const getter = (_a = SELECTOR_TYPE_GETTERS[selector_type]) !== null && _a !== void 0 ? _a : (() => []);\n    return getter(elements);\n}\n/**\n * Remove blacklisted selectors from list.\n */\nexport function filterSelectors(list = [], matchBlacklist, matchWhitelist) {\n    return list.filter((item) => matchWhitelist(item) || !matchBlacklist(item));\n}\n/**\n * Prioritise whitelisted selectors in list.\n */\nexport function orderSelectors(list = [], matchWhitelist) {\n    return list.sort((a, b) => {\n        const a_is_whitelisted = matchWhitelist(a);\n        const b_is_whitelisted = matchWhitelist(b);\n        if (a_is_whitelisted && !b_is_whitelisted) {\n            return -1;\n        }\n        if (!a_is_whitelisted && b_is_whitelisted) {\n            return 1;\n        }\n        return 0;\n    });\n}\n/**\n * Returns list of unique selectors applicable to given element.\n */\nexport function getAllSelectors(elements, root, options) {\n    const selectors_list = getSelectorsList(elements, options);\n    const type_combinations = getTypeCombinations(selectors_list, options);\n    const all_selectors = flattenArray(type_combinations);\n    return [...new Set(all_selectors)];\n}\n/**\n * Creates object containing all selector types and their potential values.\n */\nexport function getSelectorsList(elements, options) {\n    const { blacklist, whitelist, combineWithinSelector, maxCombinations } = options;\n    const matchBlacklist = createPatternMatcher(blacklist);\n    const matchWhitelist = createPatternMatcher(whitelist);\n    const reducer = (data, selector_type) => {\n        const selectors_by_type = getSelectorsByType(elements, selector_type);\n        const filtered_selectors = filterSelectors(selectors_by_type, matchBlacklist, matchWhitelist);\n        const found_selectors = orderSelectors(filtered_selectors, matchWhitelist);\n        data[selector_type] = combineWithinSelector\n            ? getPowerSet(found_selectors, { maxResults: maxCombinations })\n            : found_selectors.map((item) => [item]);\n        return data;\n    };\n    return getSelectorsToGet(options).reduce(reducer, {});\n}\n/**\n * Creates list of selector types that we will need to generate the selector.\n */\nexport function getSelectorsToGet(options) {\n    const { selectors, includeTag } = options;\n    const selectors_to_get = [].concat(selectors);\n    if (includeTag && !selectors_to_get.includes(\"tag\")) {\n        selectors_to_get.push(\"tag\");\n    }\n    return selectors_to_get;\n}\n/**\n * Adds \"tag\" to a list, if it does not contain it. Used to modify selectors\n * list when includeTag option is enabled to make sure all results contain the\n * TAG part.\n */\nfunction addTagTypeIfNeeded(list) {\n    return list.includes(CSS_SELECTOR_TYPE.tag) ||\n        list.includes(CSS_SELECTOR_TYPE.nthoftype)\n        ? [...list]\n        : [...list, CSS_SELECTOR_TYPE.tag];\n}\n/**\n * Generates list of possible selector type combinations.\n */\nexport function combineSelectorTypes(options) {\n    const { selectors, combineBetweenSelectors, includeTag, maxCandidates } = options;\n    const combinations = combineBetweenSelectors\n        ? getPowerSet(selectors, { maxResults: maxCandidates })\n        : selectors.map((item) => [item]);\n    return includeTag ? combinations.map(addTagTypeIfNeeded) : combinations;\n}\n/**\n * Generates list of combined CSS selectors.\n */\nexport function getTypeCombinations(selectors_list, options) {\n    return combineSelectorTypes(options)\n        .map((item) => {\n        return constructSelectors(item, selectors_list);\n    })\n        .filter((item) => item.length > 0);\n}\n/**\n * Generates all variations of possible selectors from provided data.\n */\nexport function constructSelectors(selector_types, selectors_by_type) {\n    const data = {};\n    selector_types.forEach((selector_type) => {\n        const selector_variants = selectors_by_type[selector_type];\n        if (selector_variants.length > 0) {\n            data[selector_type] = selector_variants;\n        }\n    });\n    const combinations = getCartesianProduct(data);\n    return combinations.map(constructSelector);\n}\n/**\n * Creates selector for given selector type. Combines several parts if needed.\n */\nexport function constructSelectorType(selector_type, selectors_data) {\n    return selectors_data[selector_type]\n        ? selectors_data[selector_type].join(\"\")\n        : \"\";\n}\n/**\n * Converts selector data object to a selector.\n */\nexport function constructSelector(selectorData = {}) {\n    const pattern = [...SELECTOR_PATTERN];\n    // selector \"nthoftype\" already contains \"tag\"\n    if (selectorData[CSS_SELECTOR_TYPE.tag] &&\n        selectorData[CSS_SELECTOR_TYPE.nthoftype]) {\n        pattern.splice(pattern.indexOf(CSS_SELECTOR_TYPE.tag), 1);\n    }\n    return pattern\n        .map((type) => constructSelectorType(type, selectorData))\n        .join(\"\");\n}\n/**\n * Generates combinations of child and descendant selectors within root\n * selector.\n */\nfunction generateCandidateCombinations(selectors, rootSelector) {\n    return [\n        ...selectors.map((selector) => rootSelector + OPERATOR.DESCENDANT + selector),\n        ...selectors.map((selector) => rootSelector + OPERATOR.CHILD + selector),\n    ];\n}\n/**\n * Generates a list of selector candidates that can potentially match target\n * element.\n */\nfunction generateCandidates(selectors, rootSelector) {\n    return rootSelector === \"\"\n        ? selectors\n        : generateCandidateCombinations(selectors, rootSelector);\n}\n/**\n * Tries to find an unique CSS selector for element within given parent.\n */\nexport function getSelectorWithinRoot(elements, root, rootSelector = \"\", options) {\n    const elementSelectors = getAllSelectors(elements, options.root, options);\n    const selectorCandidates = generateCandidates(elementSelectors, rootSelector);\n    for (const candidateSelector of selectorCandidates) {\n        if (testSelector(elements, candidateSelector, options.root)) {\n            return candidateSelector;\n        }\n    }\n    return null;\n}\n/**\n * Climbs through parents of the element and tries to find the one that is\n * identifiable by unique CSS selector.\n */\nexport function getClosestIdentifiableParent(elements, root, rootSelector = \"\", options) {\n    if (elements.length === 0) {\n        return null;\n    }\n    const candidatesList = [\n        elements.length > 1 ? elements : [],\n        ...getParents(elements, root).map((element) => [element]),\n    ];\n    for (const currentElements of candidatesList) {\n        const result = getSelectorWithinRoot(currentElements, root, rootSelector, options);\n        if (result) {\n            return {\n                foundElements: currentElements,\n                selector: result,\n            };\n        }\n    }\n    return null;\n}\n/**\n * Converts input into list of elements, removing duplicates and non-elements.\n */\nexport function sanitizeSelectorNeedle(needle) {\n    if (needle instanceof NodeList || needle instanceof HTMLCollection) {\n        needle = Array.from(needle);\n    }\n    const elements = (Array.isArray(needle) ? needle : [needle]).filter(isElement);\n    return [...new Set(elements)];\n}\n//# sourceMappingURL=utilities-selectors.js.map","/**\n * Generates cartesian product out of input object.\n */\nexport function getCartesianProduct(input = {}) {\n    let result = [];\n    Object.entries(input).forEach(([key, values]) => {\n        result = values.flatMap((value) => {\n            if (result.length === 0) {\n                return [{ [key]: value }];\n            }\n            else {\n                return result.map((memo) => (Object.assign(Object.assign({}, memo), { [key]: value })));\n            }\n        });\n    });\n    return result;\n}\n//# sourceMappingURL=utilities-cartesian.js.map","import { CSS_SELECTOR_TYPE, OPERATOR, } from \"./types.js\";\nimport { SELECTOR_PATTERN } from \"./constants.js\";\nimport { getElementSelectorsByType } from \"./utilities-selectors.js\";\n/**\n * Creates data describing a specific selector.\n */\nexport function createElementSelectorData(selector) {\n    return {\n        value: selector,\n        include: false,\n    };\n}\n/**\n * Creates data describing an element within CssSelector chain.\n */\nexport function createElementData(element, selectorTypes, operator = OPERATOR.NONE) {\n    const selectors = {};\n    selectorTypes.forEach((selectorType) => {\n        Reflect.set(selectors, selectorType, getElementSelectorsByType(element, selectorType).map(createElementSelectorData));\n    });\n    return {\n        element,\n        operator,\n        selectors,\n    };\n}\n/**\n * Constructs selector from element data.\n */\nexport function constructElementSelector({ selectors, operator, }) {\n    let pattern = [...SELECTOR_PATTERN];\n    // `nthoftype` already contains tag\n    if (selectors[CSS_SELECTOR_TYPE.tag] &&\n        selectors[CSS_SELECTOR_TYPE.nthoftype]) {\n        pattern = pattern.filter((item) => item !== CSS_SELECTOR_TYPE.tag);\n    }\n    let selector = \"\";\n    pattern.forEach((selectorType) => {\n        const selectorsOfType = selectors[selectorType] || [];\n        selectorsOfType.forEach(({ value, include }) => {\n            if (include) {\n                selector += value;\n            }\n        });\n    });\n    return (operator + selector);\n}\n//# sourceMappingURL=utilities-element-data.js.map","import { getElementParents } from \"./utilities-dom.js\";\nimport { SELECTOR_SEPARATOR } from \"./constants.js\";\nimport { CSS_SELECTOR_TYPE, OPERATOR, } from \"./types.js\";\nimport { constructElementSelector, createElementData, } from \"./utilities-element-data.js\";\n/**\n * Creates fallback selector for single element.\n */\nexport function getElementFallbackSelector(element) {\n    const parentElements = getElementParents(element).reverse();\n    const elementsData = parentElements.map((element) => {\n        const elementData = createElementData(element, [CSS_SELECTOR_TYPE.nthchild], OPERATOR.CHILD);\n        elementData.selectors.nthchild.forEach((selectorData) => {\n            selectorData.include = true;\n        });\n        return elementData;\n    });\n    return [\":root\", ...elementsData.map(constructElementSelector)].join(\"\");\n}\n/**\n * Creates chain of :nth-child selectors from root to the elements.\n */\nexport function getFallbackSelector(elements) {\n    return elements.map(getElementFallbackSelector).join(SELECTOR_SEPARATOR);\n}\n//# sourceMappingURL=selector-fallback.js.map","import { getFallbackSelector } from \"./selector-fallback.js\";\nimport { sanitizeOptions } from \"./utilities-options.js\";\nimport { getClosestIdentifiableParent, sanitizeSelectorNeedle, } from \"./utilities-selectors.js\";\nimport { testSelector } from \"./utilities-dom.js\";\nimport { SELECTOR_SEPARATOR } from \"./constants.js\";\n/**\n * Generates unique CSS selector for an element.\n */\nexport function getCssSelector(needle, custom_options = {}) {\n    const elements = sanitizeSelectorNeedle(needle);\n    const options = sanitizeOptions(elements[0], custom_options);\n    let partialSelector = \"\";\n    let currentRoot = options.root;\n    /**\n     * Utility function to make subsequent calls shorter.\n     */\n    function updateIdentifiableParent() {\n        return getClosestIdentifiableParent(elements, currentRoot, partialSelector, options);\n    }\n    let closestIdentifiableParent = updateIdentifiableParent();\n    while (closestIdentifiableParent) {\n        const { foundElements, selector } = closestIdentifiableParent;\n        if (testSelector(elements, selector, options.root)) {\n            return selector;\n        }\n        currentRoot = foundElements[0];\n        partialSelector = selector;\n        closestIdentifiableParent = updateIdentifiableParent();\n    }\n    // if failed to find single selector matching all elements, try to find\n    // selector for each standalone element and join them together\n    if (elements.length > 1) {\n        return elements\n            .map((element) => getCssSelector(element, options))\n            .join(SELECTOR_SEPARATOR);\n    }\n    return getFallbackSelector(elements);\n}\nexport default getCssSelector;\n//# sourceMappingURL=index.js.map","/**\n * Checks whether value is one of the enum's values.\n */\nexport function isEnumValue(haystack, needle) {\n    return Object.values(haystack).includes(needle);\n}\n//# sourceMappingURL=utilities-typescript.js.map"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","isElement","input","Element","OPERATOR","NONE","DESCENDANT","CHILD","CSS_SELECTOR_TYPE","id","class","tag","attribute","nthchild","nthoftype","libraryName","showWarning","args","console","warn","DEFAULT_OPTIONS","selectors","includeTag","whitelist","blacklist","combineWithinSelector","combineBetweenSelectors","maxCombinations","Number","POSITIVE_INFINITY","maxCandidates","isRegExp","RegExp","isCssSelectorMatch","includes","sanitizeCssSelectorMatchList","Array","isArray","filter","isParentNode","validParentNodeTypes","Node","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","ELEMENT_NODE","isNode","nodeType","element","contains","rootNode","getRootNode","composed","document","ownerDocument","querySelector","sanitizeMaxNumber","getIntersection","items","firstItem","otherItems","length","reduce","accumulator","currentValue","item","flattenArray","concat","createPatternMatcher","list","matchFunctions","map","test","result","re","replace","some","matchFunction","testSelector","elements","selector","from","querySelectorAll","every","getElementParents","parent","push","parentElement","getParents","SELECTOR_SEPARATOR","INVALID_ID_RE","join","INVALID_CLASS_RE","SELECTOR_PATTERN","attributeBlacklistMatch","attributeNodeToSimplifiedSelector","name","attributeNodeToSelector","sanitizeAttributeData","nodeName","nodeValue","sanitizeSelectorItem","getElementAttributeSelectors","validAttributes","attributes","attributeNode","tagName","toLowerCase","isValidAttributeNode","getElementClassSelectors","getAttribute","trim","split","getElementIdSelectors","getElementNthChildSelector","parentNode","elementIndex","childNodes","indexOf","getElementTagSelectors","getTagSelector","Set","getElementNthOfTypeSelector","siblings","children","getPowerSet","maxResults","resultCounter","offsets","generateOffsets","offset","bumpOffsets","powerSetGenerator","maxValue","size","index","keys","ESCAPED_COLON","charCodeAt","toString","toUpperCase","SPECIAL_CHARACTERS_RE","_a","_b","CSS","escape","character","legacySanitizeSelectorItem","SELECTOR_TYPE_GETTERS","ELEMENT_SELECTOR_TYPE_GETTERS","addTagTypeIfNeeded","constructSelector","selectorData","pattern","splice","type","constructSelectorType","selectors_data","selector_type","getSelectorWithinRoot","rootSelector","options","selectorCandidates","generateCandidateCombinations","generateCandidates","selectors_list","matchBlacklist","matchWhitelist","selectors_to_get","getSelectorsToGet","data","selectors_by_type","getSelectorsByType","filtered_selectors","filterSelectors","found_selectors","sort","a","b","a_is_whitelisted","b_is_whitelisted","orderSelectors","getSelectorsList","type_combinations","combinations","combineSelectorTypes","selector_types","forEach","selector_variants","entries","values","flatMap","memo","assign","getCartesianProduct","constructSelectors","getTypeCombinations","all_selectors","getAllSelectors","candidateSelector","createElementSelectorData","include","constructElementSelector","operator","selectorType","getElementFallbackSelector","reverse","elementData","selectorTypes","Reflect","set","getElementSelectorsByType","createElementData","getCssSelector","needle","custom_options","NodeList","HTMLCollection","sanitizeSelectorNeedle","isEnumValue","haystack","sanitizeOptions","partialSelector","currentRoot","updateIdentifiableParent","candidatesList","currentElements","foundElements","getClosestIdentifiableParent","closestIdentifiableParent","getFallbackSelector"],"sourceRoot":""}